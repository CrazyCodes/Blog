![](https://blog.fastrun.cn/wp-content/uploads/2018/08/1508779647-5b724c892b362_articlex.png)

# 前言
整理了一些关于PHP相关的基础。请大家随意摘看。
# 通信协议
> 网络通信协议是一种网络通用语言，为连接不同操作系统和不同硬件体系结构的互联网络引提供通信支持，是一种网络通用语言。

## 应用层
| 名称 | 注释 |
| -- | -- |
| HTTP | Hypertext Transfer Protocol 超文本传输协议，显示网页 | 
| DNS | Domain Name System 域名系统 |
| FTP | File Transfer Protocol 文件传输协议 |
| SFTP | SSH File Transfer Protocol 安全文件传送协议|
| SSH | Secure Shell | 

## 通信层
| 名称 | 注释 |
| -- | -- |
| TCP | Transmission Control Protocol 三次握手传输协议 |
| UDP | |
## 网络层
| 名称 | 注释 |
| -- | -- |
| IP | Internet Protocol |
| ICMP | Internet Control Message Protocol，主要用于路由发送错误报告 |

## HTTP
HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。

HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。

### 在TCP/IP协议栈中的位置
HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示


![clipboard.png](/img/bVLY09)

默认HTTP的端口号为80，HTTPS的端口号为443。

### HTTP的请求响应模型
HTTP协议永远都是客户端发起请求，服务器回送响应。见下图

![clipboard.png](/img/bVbfiMy)

这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。
HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。

### HTTP Request
客户端发送一个HTTP请求到服务器的请求消息包括以下格式
- 请求行（request line）
- 请求头部（header）
- 空行和请求数据四个部分组成。

Get请求例子
```
GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8
```
POST请求例子
```
POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&publisher=Wiley
```
第一部分：请求行，第一行显示请求类型，以及http1.1版本。
第二部分：请求头部，第二行至第六行。
第三部分：空行，第七行的空行。
第四部分：请求数据，第八行。

### HTTP Response
一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。
HTTP响应也由四个部分组成
- 状态行
- 消息报头
- 空行和响应正文。

```
HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8<html><head></head><body><!--body goes here--></body></html>
```
第一部分\状态行 : 由HTTP协议版本号、状态码、状态消息三部分组成。
第二部分\消息报头 : 用来说明客户端要使用的一些附加信息
第三部分\空行 : 消息报头后面的空行是必须的
第四部分\响应正文 : 服务器返回给客户端的文本信息。

### HTTP 状态码
状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别
| 状态 | 注释 |
| -- | -- |
| 1xx | 指示信息--表示请求已接收，继续处理 |
| 2xx | 成功--表示请求已被成功接收、理解、接受 | 
| 3xx | 重定向--要完成请求必须进行更进一步的操作 | 
| 4xx | 客户端错误--请求有语法错误或请求无法实现 |
| 5xx | 服务器端错误--服务器未能实现合法的请求 |

# 进程与线程
进程的概念是操作系统的结构的基础。Multics的设计者在20世纪60年代首次使用了这个技术词语,它比作业更通用一些。关于进程的定义，如下所示
- 一个正在执行的程序。 
- 计算机中正在运行的程序的一个实例。 
- 可以分配给处理器并由处理器执行的一个实体。 
- 由单一的顺序的执行线程、一个当前状态和一组相关的系统资源所描述的活动单元。

## 为什么设计了进程?
设计出一个能够协调各种不同活动的系统软件是非常困难的。

在任何时刻都有许多作业在运行中,每个作业都包括要求按照顺序执行的很多步骤，因此分析时间的序列组合是不可的。由于缺乏能够在所有活动中进行协调和合作的系统级的方法，程序员只能基于他们对操作系统所控制的环境的理解，采用自己的特殊方法。然而这种方法是很脆弱的，尤其对于一些程序设计中的小错误，因为这些错误只有在很少见的时间序列发生时才会出现。

由于需要从应用程序软件错误和硬件错误中区分出这些错误，因而诊断工作是很困难的。及时检测出错误，也很难确定原因，因为很难在线错误产生的精确场景。一般而言，产生这类错误的4个主要原因如下： 
- 不正确同步 
- 失败互斥。 
- 不确定的程序操作 
- 死锁

解决这些问题需要一种系统级别的方法监控处理器中不同程序的执行。进程的概念为此提供了基础。 

因此进程可以看做是由三部分组成的
 
- 一段可以执行的程序 
- 程序所需要的相关数据 
- 程序的执行上下文

## 进程的创建

传统地，操作系统创建进程的方式对用户和应用程序都是透明的，这在当代操作系统中也很普遍。但是允许一个进程引发另一个进程的创建将是很有用的。

例如一个程序进程可以产生另一个进程，以接受应用程序产生的数据，并将数据组织成适合以后分析的格式。新进程与应用程序并行的运行，并当得到新的数据时被激活。

这个方案对于构造应用程序是非常有用的，例如，服务器进程（如打印服务器、文件服务器）可以为它处理的每个请求产生一个新进程。当操作系统为另一个进程的显式请求产生一个新进程时，这个动作称为进程派生。

当一个进程派生另一个进程时，前一个称作父进程,被派生的进程称作子进程。在典型的情况下，相关进程需要像话之间通信和合作。对程序员来说，合作是一个非常困难的任务。

## 什么是线程
> 线程是进程的一个执行流，线程不能分配系统资源，它是进程的一部分，比进程更小的独立运行的单位

## 进程和线程的关系
进程就像地主，有土地（系统资源），线程就像佃户（线程，执行种地流程）。每个地主（进程）只要有一个干活的佃户（线程）。

进程-资源分配的最小单位，相对健壮，崩溃一般不影响其他进程，但是切换进程时耗费资源，效率差些。

线程-程序执行的最小单位，没有独立的地址空间，一个线程死掉可能整个进程就死掉，但是节省资源，切换效率高。

## PHP常见的进程和线程
- 在web应用中，我们每次访问php，就建立一个PHP进程，当然也会建立至少一个PHP线程
- PHP使用pcntl来进行多进程编程
- PHP中使用pthreads来进行多线程编程
- nginx的每个进程只有一个线程，每个线程可以处理多个客户端的访问
- php-fpm使用多进程模型，每个进程只有一个线程，每个线程只能处理一个客户端访问
- apache可能使用多进程模型，也可能使用多线程模型，取决于使用哪种SAPI



# 致谢
感谢你看到这里，有时一些底层的知识会对日常开发起到很大的作用，去理解它，并非彻底了解它。有什么问题可在评论区留言，谢谢